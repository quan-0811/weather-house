Source: Apache Cassandra Database â€“ Full Course for Beginners
link: https://www.youtube.com/watch?v=J-cSy5MeMOA

Module 1: Cassandra Intro and Background

1. Compares to relational Database
    Application >>> Model >>> Data
    Queries are king
    Primary keys are more than just for uniqueness
    Distributed Architecture
    Availability & Partition Tolerance (in CAP theorem) instead of ACID
    Denormalization instead or joins and indexes
    Referential Integrity not enforced 

2. Terminology
    data model
    keyspace: container of table
    table: rows x columns
    partition:
        data is stored based on partition
    primary key: partition key
        uniqueness
        placement of the record in the cluster -> accessibility

3. CQL Fundamentals
    Building Blocks: Keyspaces, Tables, Primary Keyspaces
    CQL Commands: SELECT, TRUNCATE, ALTER TABLE, SOURCE

4. Partitions
    Partition Keys
    Composite Partition Keys
    Clustering Columns
    

Module 2: Cassandra Building Blocks

1. Denormalization
    Construct and store the <Result of Join command> in denormalized table.
    No Join will be used later.

2. Collections, User Defined Types, and Counters
    Collection: Set, List, Map (like python Dictionary)
        Groups and stores data together in a single columns
        Collection columns are multi-valued columns
        Designed to store a small amount of data
        Retrieved in its entirety
        Cannot be part of primary key, partition key or clustering column
        Cannot nest a collection inside of another collection
            Unless you use FROZEN keyword


    User Defined Types (UDT)
        A list of component types.
        For example: CREATE TYPE full name ( first name text, last name text);

    Counters
        A dedicated type to use instead of COUNT ON in SQL

Module 3: Data Modeling
(Following DataStax Modeling Methodology)

1. Conceptual Data Model
	Abstract view of domain
	Technology independent
	Not specific to any database system
	(Which will then be normalized for SQL or further denormalized for no-SQL)

	Cardinality: relationships between two entities (1-1, 1-n, m-n)

	Relationship key: (1-1, 1-n, m-n)

	Weak entity type: (composition relation)

2. Workflow and Access Pattern
	Tasks/causal dependencies form a graph
	This create an access patterns that help determine: How data is accessed and What queries to run first

3. Mapping Rules and Patterns
	Why we need to follow mapping rules
		Ensures the correctness of logical data model
		Ensure each query has a corresponding table
		Ensure queries are executed properly
		Ensure data is returned in the correct order

	Mapping Rules
		Identify entities and their relationship
		Identify the "equality search" attributes
		Identify the "inequality search" attributes
		Identify the "ordering" attributes
		Identify the "key" attributes

	Chebotko Diagram (database schema design)
		Documents the logical and physical data model
		Includes: Application Workflow, Table Diagrams, Query List and UDTs
		In logical-level: shows column names and attributes
		In physical-level: shows column data type (with type of column and some optimization if needed)

	Principle of data modelling
		Know your Data
		Know your Queries
		Nest Data
		Duplicate Data
	
	
	Key to successful database implementation
		Preserve properties so that data is organized correctly
		Space is sacrificed to reduce time
		Define what is stored in database

	Entity and relationship keys affect the table primary keys
		Primary key uniquely identifies a row / entity / relationship

	Query is the center of data modelling
		Captured by application workflow models
		Reduce the number of partitions that have to be read for a query result
		Table schema design changes if queries change

	Single Partition per Query
		Most efficient access pattern
		Query accesses only one partition to retrieve result

	Multiple Partition per Query
		Less efficient but not necessarily bad
		Should be limited

	Anti-pattern
		(strictly avoid) Linear Search in all Partition to find an information

4. Logical Data Model
	Working rule of Cassandra: Group as much data as possible on disk
		Data Nesting is the main data modeling technique
		Organizes multiple entities into a single pertition
		Supports partition per query data access

	Scheme Design should be friven by application queries

	Three data nesting mechanism:
		Clustering columns
			Primary nesting mechanism
			Partition key identifies an entity that other entities will nest into
			Values in clustering column identify the nested entities
			Multiple clustering columns inplement multi-level nesting
		Collection columns
		UDT columns
			Secondary nesting mechanism
			Represent 1-1 relationship
			Can use in conjuction with collection
			Easier thatn working with multiple collection columns
	Result
		Data duplication
		Cassandra join on write instead of join on read

5. Physical Data Model
	Created by adding data types to each column of Logical model
	Also:
		Optimize Efficiency
		Partition size won't grow
		Return queries quickly

	
